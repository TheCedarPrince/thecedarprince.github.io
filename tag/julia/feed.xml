<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
  xmlns:content="http://purl.org/rss/1.0/modules/content/"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:media="http://search.yahoo.com/mrss/"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:georss="http://www.georss.org/georss">

  <channel>
    <title>
      <![CDATA[  the cedar ledge  ]]>
    </title>
    <link> https://jacobzelko.com </link>
    <description>
      <![CDATA[  Jacob S. Zelko&#39;s personal website  ]]>
    </description>
    <atom:link
      href="https://jacobzelko.com/feed.xml"
      rel="self"
      type="application/rss+xml" />


<item>
  <title>
    <![CDATA[  Asynchronous Workflow Using Julia Tutorial  ]]>
  </title>
  <link> https://jacobzelko.com/01082023043553-julia-async-workflow/index.html </link>
  <guid> https://jacobzelko.com/01082023043553-julia-async-workflow/index.html </guid>
  <description>
    <![CDATA[  A thorough tutorial on how to use Julia for asynchronous workflows to do many things, at once&#33;  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  
<h1>Asynchronous Workflow Using Julia Tutorial</h1>
<p><strong>Date:</strong> January 7 2023</p>
<p><strong>Summary:</strong> A thorough tutorial on how to use Julia for asynchronous workflows to do many things, at once&#33;</p>
<p><strong>Keywords:</strong> #blog #archive #julia #programming #literate #workflow #asynchronous #weave #browser #sync #node</p>
<h1>Bibliography</h1>
<p>Not Available</p>
<h1>Table of Contents</h1>
<div class="franklin-toc"><ol><li><ol><li>Motivation</li><li>Set-Up</li><li>Simple Workflow Process<ol><li>Blocking Workflow</li><li>Asynchronous Workflow</li></ol></li><li>Asynchronous Workflow for Literate Programming</li><li>Conclusion</li></ol></li><li>How To Cite</li><li>References:</li><li>Discussion: </li></ol></div>
<h3 id="motivation">Motivation</h3>
<p>I sometimes find myself wanting to execute a Julia file I have just edited.  This is different than what the excellent <a href="https://jacobzelko.com/https://github.com/timholy/Revise.jl">Revise.jl package &#40;created by Tim Holy&#41;</a> does in that I want to execute the full file and not just update function definitions. Moreover, I may just want Julia to do something else entirely upon updating a file or directory. This can be very helpful in analysis workflows as well as literate programming. Creating an extended post on my process for this was inspired by a <a href="https://jacobzelko.com/https://discourse.julialang.org/t/franklin-jl-automatically-evaluate-jl-file-on-change/92580/6">Julia Discourse post I provided an answer to</a>.</p>
<h3 id="set-up">Set-Up</h3>
<p>Here is how I recommend setting up your Julia environment to follow this tutorial &#40;I assume you have Julia installed correctly&#41;:</p>
<ol>
<li><p>Create an empty directory &#40;folder&#41; somewhere on your computer. &#40;NOTE: For sake of this tutorial, I will refer to it as the &quot;test&quot; folder&#41;.</p>
</li>
<li><p>Within your favorite text editor &#40;like Notepad, Vim, VSCode, etc.&#41;, open this directory.</p>
</li>
<li><p>Open and create a file called &quot;tmp.jmd&quot; &#40;NOTE: Keep the file and your editor open as we will be coming back to this file quite a lot&#41;.</p>
</li>
<li><p>Open your Julia REPL within the directory and activate a temporary environment within package mode:</p>
</li>
</ol>
<pre><code class="language-julia-repl">pkg&gt; activate --temp</code></pre>
<ol start="5">
<li><p>Add into this temporary environment the following packages:</p>
</li>
</ol>
<pre><code class="language-julia-repl">pkg&gt; add FileWatching, Weave</code></pre>
<ol start="6">
<li><p>Install node onto your machine.</p>
</li>
</ol>
<p>I suggest using the great tool, <a href="https://jacobzelko.com/https://github.com/nvm-sh/nvm"><code>nvm</code>, which allows easy management of node versions</a>.</p>
<ol start="7">
<li><p>Install the node package, <a href="https://jacobzelko.com/https://www.npmjs.com/package/browser-sync"><code>browser-sync</code>, which allows for syncing of webpages based on updates</a>.</p>
</li>
</ol>
<p>Here is the command you can use in your command line: </p>
<pre><code class="language-sh">npm i -g browser-sync</code></pre>
<blockquote>
<p>NOTE: Steps 6 and 7 are not necessary if you are not interested in the <a href="https://jacobzelko.com/#asynchronous-workflow-for-literate-programming">section on literate programming</a></p>
</blockquote>
<h3 id="simple_workflow_process">Simple Workflow Process</h3>
<p>There are two ways to start this workflow.  One blocking &#40;i.e. you cannot use the Julia REPL while working&#41; and another spawning an asynchronous background process to enable you to work with the same REPL. Here is gif showing these workflows in action:</p>
<p><img src="assets/01082023043553-watching-example.gif" alt="" /></p>
<h4 id="blocking_workflow">Blocking Workflow</h4>
<p>This creates a synchronous task in your Julia REPL that can then run whatever command you want while you monitor a specific file &#40;or folder&#41;. In this case, I am making the task print a statement that says “Change Detected&#33;” to my REPL whenever there is a change in the file called “tmp.jmd”.</p>
<pre><code class="language-julia">using FileWatchingwhile true 
    watch_file&#40;&quot;./tmp.jmd&quot;&#41;
    println&#40;&quot;Change Detected&#33;&quot;&#41;
end</code></pre>
<p>This workflow is not optimal as this loop continues and locks your REPL from doing anything else. </p>
<h4 id="asynchronous_workflow">Asynchronous Workflow</h4>
<p>This creates an asynchronous task in the background of your Julia REPL that can then run whatever command you want while you monitor a specific file &#40;or folder&#41;. In this case, I am making the task print a statement that says “Change Detected&#33;” to my REPL whenever there is a change in the file called “tmp.jmd”.</p>
<pre><code class="language-julia">using FileWatching@async while true 
    watch_file&#40;&quot;./tmp.jmd&quot;&#41;
    println&#40;&quot;Change Detected&#33;&quot;&#41;
end</code></pre>
<p>From here, you could then still interact with this REPL while this task is running in the background. Furthermore, you can change the line that says <code>println&#40;&quot;Change Detected&#33;&quot;&#41;</code> to whatever command &#40;or commands&#41; you want to trigger.</p>
<h3 id="asynchronous_workflow_for_literate_programming">Asynchronous Workflow for Literate Programming</h3>
<p>This workflow allows one to work with a Julia Markdown document with <code>Weave.jl</code> to preview your work in real time.  There a few steps to start the workflow but here is how it looks when in operation:</p>
<p><img src="assets/01082023043553-weave-example.gif" alt="" /></p>
<p>First, execute the following snippet in your Julia REPL to start the asynchronous process to watch for changes and tell Julia to weave the file we will modify:</p>
<pre><code class="language-julia">using FileWatching
using Weave@async while true 
    watch_file&#40;&quot;./tmp.jmd&quot;&#41;
    weave&#40;&quot;./tmp.jmd&quot;&#41;
end</code></pre>
<p>Next, run this in a separate terminal:</p>
<pre><code class="language-sh">browser-sync start --server --start --file &quot;./*.html&quot;</code></pre>
<p>or this command within your Julia REPL &#40;NOTE: This will make your REPL session very cluttered but you can still use your REPL&#41;:</p>
<pre><code class="language-julia">@async run&#40;&#96;browser-sync start --server --start --file &quot;./*.html&quot;&#96;&#41;</code></pre>
<p>At this point, you should see <code>browser-sync</code> spit out a lot of information that looks something like this:</p>
<pre><code class="language-sh">&#91;Browsersync&#93; Access URLs:
 --------------------------------------
       Local: http://localhost:3000
    External: http://192.168.1.186:3000
 --------------------------------------
          UI: http://localhost:3001
 UI External: http://localhost:3001
 --------------------------------------
&#91;Browsersync&#93; Serving files from: ./</code></pre>
<p>You&#39;ll want to grab that URL that looks like <code>http://localhost:3000</code> in the <code>Local</code> spot and then open that in your web browser.  With the URL that you get &#40;it could be on a different port&#41;, navigate to <code>http://localhost:3000/tmp.html</code>.</p>
<p>Finally, when you have this all in place, go ahead and add this code block into the <code>tmp.jmd</code> file that was created:</p>
<pre><code class="language-markdown"># Hello World This is a Julia Markdown file. &#96;&#96;&#96;julia 
2 &#43; 2
&#96;&#96;&#96;</code></pre>
<p>You should see a few things happen.  You&#39;ll see a few messages from the Julia REPL stating that <code>Weave.jl</code> is weaving your document to your desired output. Then, you&#39;ll see <code>browser-sync</code> say something about updating or syncing.  Finally, you will see your browser update to the latest version of your weaved document. </p>
<p>Feel free to play around with this more and see the dynamism of the workflow&#33; I tend to do this when I am iteratively developing reports within Julia and want to tinker within the REPL at the same time I am creating documents. Having to wait for rendering <code>Weave.jl</code> documents and the like was a pain and this took the pain away.</p>
<h3 id="conclusion">Conclusion</h3>
<p>I hope you appreciated this post&#33; If you have any suggestions, comments, or additional workflows this could be used for, please comment below.  May your Julia sessions now be even more supercharged&#33;</p>
<h2 id="how_to_cite">How To Cite</h2>
<p>Zelko, Jacob. <em>Asynchronous Workflow Using Julia Tutorial</em>. <a href="https://jacobzelko.com/01082023043553-julia-async-workflow">https://jacobzelko.com/01082023043553-julia-async-workflow</a>. January 7 2023.</p>
<h2 id="references">References:</h2>
<h2 id="discussion">Discussion: </h2>
<script src="https://giscus.app/client.js"
    data-repo="TheCedarPrince/thecedarprince.github.io"
    data-repo-id="R_kgDOHRFrHA"
    data-category="General"
    data-category-id="DIC_kwDOHRFrHM4CPGIX"
    data-mapping="url"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="dark_dimmed"
    data-lang="en"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
</script>
 ]]>
  </content:encoded>
    
  <pubDate>Sat, 07 Jan 2023 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jacob Zelko</atom:name>
  </atom:author>
        
</item>

<item>
  <title>
    <![CDATA[  Setting Up Julia LSP for Neovim  ]]>
  </title>
  <link> https://jacobzelko.com/08312022162228-julia-lsp-setup/index.html </link>
  <guid> https://jacobzelko.com/08312022162228-julia-lsp-setup/index.html </guid>
  <description>
    <![CDATA[  An explanation of how to setup the Julia LSP for Neovim  ]]>
  </description>  
  
  <content:encoded>
    <![CDATA[  
<h1>Setting Up Julia LSP for Neovim</h1>
<p><strong>Date:</strong> August 31 2022</p>
<p><strong>Summary:</strong> An explanation of how to setup the Julia LSP for Neovim</p>
<p><strong>Keywords:</strong> ##summary #neovim #julia #programming #archive</p>
<h1>Bibliography</h1>
<p>Not Available</p>
<h1>Table of Contents</h1>
<div class="franklin-toc"><ol><li><ol><li>General Guide</li></ol></li><li>How To Cite</li><li>References</li><li>Discussion: </li></ol></div>
<h3 id="general_guide">General Guide</h3>
<p>This is from Fredrik Ekre at the <a href="https://jacobzelko.com/https://discourse.julialang.org/t/neovim-languageserver-jl/37286/72?u&#61;thecedarprince">Julia Discourse</a> with some minimal changes and notes from me:</p>
<p>LanguageServer is somewhat slow to start so it is very useful to use a custom sysimage using PackageCompiler to reduce this time. On my machine I get the first response after 20&#43; seconds, but with a custom sysimage I can execute LS commands instantaneously.</p>
<p>Here is my setup:</p>
<ol>
<li><p>Install <code>Mason.nvim</code> or <code>nvim-lspconfig</code> and install <code>julials</code> &#40;it may also be called something like Julia Language Server Protocol&#41;.</p>
</li>
<li><p>Modify <code>init.vim</code> or <code>init.lua</code> to use a custom Julia executable &#40;if it exists&#41;:</p>
</li>
</ol>
<pre><code class="language-lua">require&#39;lspconfig&#39;.julials.setup&#123;
    on_new_config &#61; function&#40;new_config, _&#41;
        local julia &#61; vim.fn.expand&#40;&quot;~/.julia/environments/nvim-lspconfig/bin/julia&quot;&#41;
        if require&#39;lspconfig&#39;.util.path.is_file&#40;julia&#41; then
	    vim.notify&#40;&quot;Hello&#33;&quot;&#41;
            new_config.cmd&#91;1&#93; &#61; julia
        end
    end
&#125;</code></pre>
<p>&#40;OPTIONAL&#41; If you use Packer to manage your vim setup, run <code>PackerCompile</code>.</p>
<p>NOTE: If you notice, there is a small line named <code>vim.notify&#40;&quot;Hello&#33;&quot;&#41;</code>. This is to test that <code>julials</code> is engaged when accessing a Julia file - you can check that it is engaged by writing <code>:messages</code> in vim. You should see &quot;Hello&#33;&quot; appear. This line can then safely be removed. </p>
<ol start="3">
<li><p>Create the <code>nvim-lspconfig</code> Julia environment by running the following in your shell:</p>
</li>
</ol>
<pre><code class="language-sh">julia --project&#61;~/.julia/environments/nvim-lspconfig -e &#39;using Pkg; Pkg.add&#40;&quot;LanguageServer&quot;&#41;&#39;</code></pre>
<p>And then navigate to the directory at <code>~.julia/environment/nvim-lspconfig</code>.</p>
<ol start="3">
<li><p>Copy the following makefile &#40;<a href="https://jacobzelko.com/https://github.com/fredrikekre/.dotfiles/blob/master/.julia/environments/nvim-lspconfig/Makefile">courtesy of Fredrik Ekre</a>&#41; the <code>nvim-lspconfig</code> directory with the name <code>makefile</code>:</p>
</li>
</ol>
<pre><code class="language-make"># MIT License. Copyright &#40;c&#41; 2021 Fredrik Ekre
#
# This Makefile can be used to build a custom Julia system image for LanguageServer.jl to
# use with neovims built in LSP support. An up-to date version of this Makefile can be found
# at https://github.com/fredrikekre/.dotfiles/blob/master/.julia/environments/nvim-lspconfig/Makefile
#
# Usage instructions:
#
#   1. Update the neovim configuration to use a custom julia executable. If you use
#      nvim-lspconfig &#40;recommended&#41; you can modify the setup call to the following:
#
#          require&#40;&quot;lspconfig&quot;&#41;.julials.setup&#40;&#123;
#              on_new_config &#61; function&#40;new_config, _&#41;
#                  local julia &#61; vim.fn.expand&#40;&quot;~/.julia/environments/nvim-lspconfig/bin/julia&quot;&#41;
#                  if require&#40;&quot;lspconfig&quot;&#41;.util.path.is_file&#40;julia&#41; then
#                      new_config.cmd&#91;1&#93; &#61; julia
#                  end
#              end,
#              -- ...
#          &#125;&#41;
#
#   2. Place this Makefile in ~/.julia/environments/nvim-lspconfig &#40;create the directory if
#      it doesn&#39;t already exist&#41;.
#
#   3. Change directory to ~/.julia/environments/nvim-lspconfig and run &#96;make&#96;. This will
#      start up neovim in a custom project with a julia process that recods compiler
#      statements. Follow the instructions in the opened source file, and then exit neovim.
#
#   4. Upon exiting neovim PackageCompiler.jl will compile a custom system image which will
#      automatically be used whenever you work on Julia projects in neovim.
#
# Update instructions:
#
#  To update the system image &#40;e.g. when upgrading Julia or upgrading LanguageServer.jl or
#  it&#39;s dependencies&#41; run the following commands from the
#  ~/.julia/environments/nvim-lspconfig directory:
#
#      julia --project&#61;. -e &#39;using Pkg; Pkg.update&#40;&#41;&#39;
#      makeJULIA&#61;&#36;&#40;shell which julia&#41;
JULIA_PROJECT&#61;
SRCDIR:&#61;&#36;&#40;shell dirname &#36;&#40;abspath &#36;&#40;firstword &#36;&#40;MAKEFILE_LIST&#41;&#41;&#41;&#41;
ifeq &#40;&#36;&#40;shell uname -s&#41;,Linux&#41;
	SYSIMAGE&#61;languageserver.so
else
	SYSIMAGE&#61;languageserver.dylib
endifdefault: &#36;&#40;SYSIMAGE&#41;&#36;&#40;SYSIMAGE&#41;: Manifest.toml packagecompiler/Manifest.toml packagecompiler/precompile_statements.jl
	JULIA_LOAD_PATH&#61;&#36;&#123;PWD&#125;:&#36;&#123;PWD&#125;/packagecompiler:@stdlib &#36;&#123;JULIA&#125; -e &#39;using PackageCompiler; PackageCompiler.create_sysimage&#40;:LanguageServer, sysimage_path&#61;&quot;&#36;&#40;SYSIMAGE&#41;&quot;, precompile_statements_file&#61;&quot;packagecompiler/precompile_statements.jl&quot;&#41;&#39;Manifest.toml: Project.toml
	JULIA_LOAD_PATH&#61;&#36;&#123;PWD&#125;/Project.toml:@stdlib &#36;&#123;JULIA&#125; -e &#39;using Pkg; Pkg.instantiate&#40;&#41;&#39;Project.toml:
	JULIA_LOAD_PATH&#61;&#36;&#123;PWD&#125;/Project.toml:@stdlib &#36;&#123;JULIA&#125; -e &#39;using Pkg; Pkg.add&#40;&quot;LanguageServer&quot;&#41;&#39;packagecompiler/Manifest.toml: packagecompiler/Project.toml
	JULIA_LOAD_PATH&#61;&#36;&#123;PWD&#125;/packagecompiler/Project.toml:@stdlib &#36;&#123;JULIA&#125; -e &#39;using Pkg; Pkg.instantiate&#40;&#41;&#39;packagecompiler/Project.toml:
	mkdir -p packagecompiler
	JULIA_LOAD_PATH&#61;&#36;&#123;PWD&#125;/packagecompiler/Project.toml:@stdlib &#36;&#123;JULIA&#125; -e &#39;using Pkg; Pkg.add&#40;&quot;PackageCompiler&quot;&#41;&#39;packagecompiler/precompile_statements.jl: Manifest.toml bin/julia
	TMPDIR&#61;&#36;&#40;shell mktemp -d&#41; &amp;&amp; \
	cd &#36;&#36;&#123;TMPDIR&#125; &amp;&amp; \
	JULIA_LOAD_PATH&#61;: &#36;&#123;JULIA&#125; -e &#39;using Pkg; Pkg.generate&#40;&quot;Example&quot;&#41;&#39; 2&gt; /dev/null &amp;&amp; \
	cd Example &amp;&amp; \
	JULIA_LOAD_PATH&#61;&#36;&#36;&#123;PWD&#125;:@stdlib &#36;&#123;JULIA&#125; -e &#39;using Pkg; Pkg.add&#40;&#91;&quot;JSON&quot;, &quot;fzf_jll&quot;, &quot;Random&quot;, &quot;Zlib_jll&quot;&#93;&#41;&#39; 2&gt; /dev/null &amp;&amp; \
	JULIA_LOAD_PATH&#61;&#36;&#36;&#123;PWD&#125;:@stdlib &#36;&#123;JULIA&#125; -e &#39;using Pkg; Pkg.precompile&#40;&#41;&#39; 2&gt; /dev/null &amp;&amp; \
	echo &quot;&#36;&#36;PACKAGE_CONTENT&quot; &gt; src/Example.jl &amp;&amp; \
	JULIA_TRACE_COMPILE&#61;1 nvim src/Example.jl &amp;&amp; \ # NOTE: You may need to check that neovim is correctly on your path
	rm -rf &#36;&#36;&#123;TMPDIR&#125;bin/julia:
	mkdir -p bin
	echo &quot;&#36;&#36;JULIA_SHIM&quot; &gt; &#36;@
	chmod &#43;x &#36;@clean:
	rm -rf &#36;&#40;SYSIMAGE&#41; packagecompiler bin.PHONY: clean defaultexport JULIA_SHIM
define JULIA_SHIM
#&#33;/bin/bash
JULIA&#61;&#36;&#123;JULIA&#125;
if &#91;&#91; &#36;&#36;&#123;JULIA_TRACE_COMPILE&#125; &#61; &quot;1&quot; &#93;&#93;; then
    exec &#36;&#36;&#123;JULIA&#125; --trace-compile&#61;&#36;&#123;PWD&#125;/packagecompiler/precompile_statements.jl &quot;&#36;&#36;@&quot;
elif &#91;&#91; -f &#36;&#123;PWD&#125;/&#36;&#40;SYSIMAGE&#41; &#93;&#93;; then
    exec &#36;&#36;&#123;JULIA&#125; --sysimage&#61;&#36;&#123;PWD&#125;/&#36;&#40;SYSIMAGE&#41; &quot;&#36;&#36;@&quot;
else
    exec &#36;&#36;&#123;JULIA&#125; &quot;&#36;&#36;@&quot;
fi
endefexport PACKAGE_CONTENT
define PACKAGE_CONTENT
# This file is opened in neovim with a LanguageServer.jl process that records Julia
# compilation statements for creating a custom sysimage.
#
# This file has a bunch of linter errors which will exercise the linter and record
# statements for that. When the diagnostic messages corresponding to those errors show up in
# the buffer the language server should be ready to accept other commands &#40;note: this may
# take a while -- be patient&#41;. Here are some suggestions for various LSP functionality that
# can be exercised &#40;your regular keybindings should work&#41;:
#
#  - :lua vim.lsp.buf.hover&#40;&#41;
#  - :lua vim.lsp.buf.definition&#40;&#41;
#  - :lua vim.lsp.buf.references&#40;&#41;
#  - :lua vim.lsp.buf.rename&#40;&#41;
#  - :lua vim.lsp.buf.formatting&#40;&#41;
#  - :lua vim.lsp.buf.formatting_sync&#40;&#41;
#  - :lua vim.lsp.buf.code_action&#40;&#41;
#  - Tab completion &#40;if you have set this up using LSP&#41;
#  - ...
#
# When you are finished, simply exit neovim and PackageCompiler.jl will use all the recorded
# statements to create a custom sysimage. This sysimage will be used for the language server
# process in the future, and should result in almost instant response.module Exampleimport JSON
import fzf_jll
using Random
using Zlib_jllfunction hello&#40;who, notused&#41;
    println&#40;&quot;hello&quot;, who&#41;
    shuffle&#40;&#91;1, 2, 3&#93;&#41;
   shoffle&#40;&#91;1, 2, 3&#93;&#41;
    fzzf &#61; fzf_jll.fzzf&#40;&#41;
    fzf &#61; fzf_jll.fzf&#40;1&#41;
    JSON.print&#40;stdout, Dict&#40;&quot;hello&quot; &#61;&gt; &#91;1, 2, 3&#93;&#41;, 2, 123&#41;
    JSON.print&#40;stdout, Dict&#40;&quot;hello&quot; &#61;&gt; &#91;1, 2, 3&#93;&#41;&#41;
    hi&#40;who&#41;
    return Zlib_jll.libz
endfunction world&#40;s&#41;
    if s &#61;&#61; nothing
      hello&#40;s&#41;
  else
      hello&#40;s&#41;
  end
    x &#61; &#91;1, 2, 3&#93;
    for i in 1:length&#40;x&#41;
        println&#40;x&#91;i&#93;&#41;
    end
endend # module
endef</code></pre>
<ol start="4">
<li><p>Run <code>make</code>. This will set up a dummy project and launch nvim with julia recording everything that is compiled. Wait until the LanguageServer responds &#40;there are a bunch of things in this dummy project that will result in warnings&#41; and then run some LanguageServer commands, for example <code>::lua vim.lsp.buf.hover&#40;&#41;</code> to fetch documentation&#41;.</p>
</li>
<li><p>Quit vim.</p>
</li>
<li><p>PackageCompiler will now build a custom <code>languageserver.so</code> sysimage.</p>
</li>
<li><p>Enjoy the Julia LSP&#33;</p>
</li>
</ol>
<h2 id="how_to_cite">How To Cite</h2>
<p>Zelko, Jacob. <em>Setting Up Julia LSP for Neovim</em>. <a href="https://jacobzelko.com/08312022162228-julia-lsp-setup">https://jacobzelko.com/08312022162228-julia-lsp-setup</a>. August 31 2022.</p>
<h2 id="references">References</h2>
<h2 id="discussion">Discussion: </h2>
<script src="https://giscus.app/client.js"
    data-repo="TheCedarPrince/thecedarprince.github.io"
    data-repo-id="R_kgDOHRFrHA"
    data-category="General"
    data-category-id="DIC_kwDOHRFrHM4CPGIX"
    data-mapping="url"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="dark_dimmed"
    data-lang="en"
    data-loading="lazy"
    crossorigin="anonymous"
    async>
</script>
 ]]>
  </content:encoded>
    
  <pubDate>Wed, 31 Aug 2022 00:00:00 +0000</pubDate>  
  
  
  <atom:author>
    <atom:name>Jacob Zelko</atom:name>
  </atom:author>
        
</item>
</channel></rss>